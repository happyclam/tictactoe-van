// Generated by CoffeeScript 1.12.2
(function() {
  var Board, Const, Game, Player, Tree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(jQuery) {
    var $;
    $ = jQuery;
    return $.fn.pointer = function(settings) {
      var defaultConfig, options;
      defaultConfig = {
        target: '#canvasMain'
      };
      options = $.extend(defaultConfig, settings);
      this.each(function() {
        var me;
        me = $(this);
        me.css({
          'position': 'relative'
        });
        $(options.target).click(function(e) {
          var clickX, clickY, locate, pos, radius, x, y;
          clickX = Math.floor(e.offsetX / options.divide);
          clickY = Math.floor(e.offsetY / options.divide);
          locate = clickX + clickY * 3;
          radius = options.divide / 2;
          x = (options.divide * (locate % 3)) + radius + e.currentTarget.offsetLeft;
          y = (options.divide * Math.floor(locate / 3)) + radius + e.currentTarget.offsetTop;
          pos = {
            top: y - radius,
            left: x - radius,
            height: options.divide * 0.9,
            width: options.divide * 0.9
          };
          me.append('<div class="ripple"></div>');
          me.find('.ripple:last').css({
            'position': 'absolute',
            'z-index': 9999,
            'height': pos.height,
            'width': pos.width,
            'border': 'solid 4px #ccc',
            'opacity': 0.3,
            'background': '#ccc'
          }).css({
            'top': pos.top,
            'left': pos.left
          }).animate({
            'height': 1,
            'width': 1,
            'left': x - 5,
            'top': y - 5
          }, {
            duration: 300,
            queue: false
          }).fadeOut(500, function() {
            $(this).remove();
          });
        });
      });
    };
  })(jQuery);

  $(function() {
    var Tictactoe;
    return Tictactoe = new Game;
  });

  Tree = (function() {
    var good_move, idx;

    Tree.counter = 0;

    Tree.total = 0;

    Tree.pebbles = 0;

    function Tree(v, score) {
      if (score == null) {
        score = [];
      }
      this.value = v;
      this.child = [];
      this.score = score.length === 0 ? this.makescore(v) : score;
    }

    Tree.toHex = function(val) {
      var i, j, len, ret, v;
      ret = "";
      for (i = j = 0, len = val.length; j < len; i = ++j) {
        v = val[i];
        if (i === 0) {
          ret += v[0] === 0 ? "9" : v[0].toString();
        } else {
          ret += v[0].toString();
        }
      }
      if (ret === "") {
        return 0;
      } else {
        return parseInt(ret, 16);
      }
    };

    Tree.toAry = function(val) {
      var i, j, len, ref, ret, temp, v;
      ret = [];
      if (val <= 0) {
        return ret;
      }
      temp = val.toString(16);
      ref = temp.split('');
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];
        if (i === 0) {
          ret.push([(v === "9" ? 0 : parseInt(v)), ((i % 2) === 0 ? Const.CROSS : Const.NOUGHT)]);
        } else {
          ret.push([parseInt(v), ((i % 2) === 0 ? Const.CROSS : Const.NOUGHT)]);
        }
      }
      return ret;
    };

    Tree.deserialize = function(src) {
      var b, i, j, len, node, ref, root;
      root = new Tree(src.value, src.score);
      ref = src.child;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        b = ref[i];
        node = new Tree(b.value, b.score);
        root.child.push(node);
        this.build(node, b);
      }
      return root;
    };

    Tree.build = function(parent, src) {
      var c, j, len, node, ref, results;
      ref = src.child;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        node = new Tree(c.value, c.score);
        parent.child.push(node);
        results.push(this.build(node, c));
      }
      return results;
    };

    Tree.prototype.count = function(v) {
      var j, len, o, ref;
      ref = this.child;
      for (j = 0, len = ref.length; j < len; j++) {
        o = ref[j];
        if (o.value.toString() === v.toString()) {
          Tree.counter += 1;
        } else {
          Tree.counter = o.count(v);
        }
      }
      return Tree.counter;
    };

    Tree.prototype.makescore = function(_q) {
      var board, j, len, score, v;
      score = [Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES, Const.PEBBLES];
      board = Tree.toAry(_q);
      for (j = 0, len = board.length; j < len; j++) {
        v = board[j];
        if (v != null) {
          score[v[0]] = null;
        }
      }
      return score;
    };

    Tree.prototype.add = function(target, obj) {
      var i, j, k, len, ref, ret;
      ret = null;
      ref = this.child;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        k = ref[i];
        if (k.value === target) {
          ret = k.child.push(obj);
        } else {
          ret = k.add(target, obj);
        }
        if (ret != null) {
          break;
        }
      }
      return ret;
    };

    Tree.prototype.apply = function(v) {
      var node;
      node = this.search(v);
      if (node != null) {
        return idx.call(this, node.score);
      } else {
        console.log("=== Not Found ===");
        return null;
      }
    };

    Tree.prototype.search = function(v) {
      var c, comp, hexValue, j, len, ref, ret;
      if (v == null) {
        return null;
      }
      if (v._i > Const.GAUGE) {
        if ((v._i % 2) === 1) {
          comp = [].concat(v._q.slice(-(Const.GAUGE - 1), +(v._q.length - 1) + 1 || 9e9), [v._q[v._q.length - Const.GAUGE]]);
        } else {
          comp = [].concat(v._q.slice(v._q.length - Const.GAUGE, +(v._q.length - 1) + 1 || 9e9));
        }
      } else {
        comp = [].concat(v._q);
      }
      hexValue = Tree.toHex(comp);
      if (this.value === hexValue) {
        return this;
      }
      ret = null;
      ref = this.child;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        if (c.value === hexValue) {
          ret = c;
        } else {
          ret = c.search(v);
        }
        if (ret != null) {
          break;
        }
      }
      return ret;
    };

    good_move = function(board) {
      var aryValue, good, i, v;
      aryValue = Tree.toAry(board.value);
      good = 0;
      switch (aryValue.length) {
        case 0:
          good = ((function() {
            var j, len, ref, results;
            ref = board.score;
            results = [];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              v = ref[i];
              if (i % 2 === 1) {
                results.push(v);
              }
            }
            return results;
          })()).reduce(function(t, s) {
            return t + s;
          });
          break;
        case 1:
          if (aryValue[0][0] === 0 || aryValue[0][0] === 2 || aryValue[0][0] === 6 || aryValue[0][0] === 8) {
            good = ((function() {
              var j, len, ref, results;
              ref = board.score;
              results = [];
              for (i = j = 0, len = ref.length; j < len; i = ++j) {
                v = ref[i];
                if (i === 4) {
                  results.push(v);
                }
              }
              return results;
            })()).reduce(function(t, s) {
              return t + s;
            });
          } else if (aryValue[0][0] === 4) {
            good = ((function() {
              var j, len, ref, results;
              ref = board.score;
              results = [];
              for (i = j = 0, len = ref.length; j < len; i = ++j) {
                v = ref[i];
                if (i === 0 || i === 2 || i === 6 || i === 8) {
                  results.push(v);
                }
              }
              return results;
            })()).reduce(function(t, s) {
              return t + s;
            });
          } else {
            good = 0;
          }
          break;
        default:
          good = 0;
      }
      return good;
    };

    idx = function(score) {
      var i, index, j, len, ret, start, v;
      ret = null;
      index = ((Math.random() * score.reduce(function(t, s) {
        return t + s;
      })) * 10) / 10.0;
      start = 0;
      for (i = j = 0, len = score.length; j < len; i = ++j) {
        v = score[i];
        if (!v) {
          continue;
        }
        start += v;
        if (start > index) {
          ret = i;
          break;
        }
      }
      return ret;
    };

    return Tree;

  })();

  Const = (function() {
    function Const() {}

    Const.NOUGHT = 1;

    Const.CROSS = -1;

    Const.DRAW = 0;

    Const.ON = 1;

    Const.OFF = 0;

    Const.EASY = 0;

    Const.NORMAL = 1;

    Const.ONGOING = 999;

    Const.MAX_VALUE = 9;

    Const.MIN_VALUE = -9;

    Const.LINE_WIDTH = 8;

    Const.RED_LINE_WIDTH = 14;

    Const.PEBBLES = 1.0;

    Const.ALL_NODES = 79210;

    Const.GAUGE = 6;

    Const.DATA_READ_ERROR = "Learning data is broken. Initialization is necessary.";

    Const.DATA_ERROR = "Learning data is broken. Please try 'Erase data'.";

    Const.DATA_LEARN_WRITE_ERROR = "Failed to write learning data";

    Const.DATA_NO_NODE = "Data not found";

    Const.IMG_SEED = "fancySerialNo";

    Const.SAVING_MESSAGE = "Saving Learning Data...";

    Const.INITIALIZING_MSG = "Data Initializing...";

    Const.RESTART_MSG = "Restart please!";

    return Const;

  })();

  Board = (function(superClass) {
    var drawanimation;

    extend(Board, superClass);

    Board.lines = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];

    Board.lineno = null;

    Board.canvas = null;

    Board.request = null;

    Board.amount = 0;

    Board.divide = 0;

    Board.radius = 0;

    Board.statusarea = null;

    Board.animate = function() {
      Board.request = requestAnimFrame(Board.animate, Board.canvas);
      return drawanimation.call(Board);
    };

    drawanimation = function() {
      var context, ended, newX, newY, start;
      start = {
        y: 0,
        x: 0
      };
      ended = {
        y: 0,
        x: 0
      };
      context = Board.canvas.getContext('2d');
      Board.amount += 0.02;
      if (Board.amount > 1) {
        Board.amount = 1;
      }
      switch (Board.lineno) {
        case 0:
          start.x = 25;
          start.y = Math.floor(Board.divide / 2);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide / 2);
          break;
        case 1:
          start.x = 25;
          start.y = Math.floor(Board.divide * 1.5);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide * 1.5);
          break;
        case 2:
          start.x = 25;
          start.y = Math.floor(Board.divide * 2.5);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide * 2.5);
          break;
        case 3:
          start.x = Math.floor(Board.divide / 2);
          start.y = 25;
          ended.x = Math.floor(Board.divide / 2);
          ended.y = Board.canvas.height - 25;
          break;
        case 4:
          start.x = Math.floor(Board.divide * 1.5);
          start.y = 25;
          ended.x = Math.floor(Board.divide * 1.5);
          ended.y = Board.canvas.height - 25;
          break;
        case 5:
          start.x = Math.floor(Board.divide * 2.5);
          start.y = 25;
          ended.x = Math.floor(Board.divide * 2.5);
          ended.y = Board.canvas.height - 25;
          break;
        case 6:
          start.x = 25;
          start.y = 25;
          ended.x = Board.canvas.width - 25;
          ended.y = Board.canvas.height - 25;
          break;
        case 7:
          start.x = 25;
          start.y = Board.canvas.height - 25;
          ended.x = Board.canvas.width - 25;
          ended.y = 25;
      }
      context.beginPath();
      context.moveTo(start.x, start.y);
      context.strokeStyle = 'rgba(255, 105, 180, 0.2)';
      context.lineWidth = Const.RED_LINE_WIDTH;
      newX = start.x + (ended.x - start.x) * Board.amount;
      newY = start.y + (ended.y - start.y) * Board.amount;
      context.lineTo(newX, newY);
      context.stroke();
      if (newX === ended.x && newY === ended.y) {
        cancelRequestAnimFrame(Board.request);
        Board.request = null;
        return Board.amount = 0;
      }
    };

    Board.display = function(board, overflg, difficulty) {
      var context, i, j, ref, results, x, y;
      if (overflg !== 0) {
        Board.animate();
      }
      if (!((Board.statusarea.innerHTML === Const.INITIALIZING_MSG) || (Board.statusarea.innerHTML === Const.RESTART_MSG))) {
        Board.statusarea.innerHTML = (function() {
          switch (board.teban) {
            case Const.NOUGHT:
              return "◯の番";
            case Const.CROSS:
              return "×の番";
            default:
              return "";
          }
        })();
      }
      context = Board.canvas.getContext('2d');
      context.beginPath();
      context.fillStyle = "#2f4f4f";
      context.fillRect(0, 0, Board.canvas.width, Board.canvas.height);
      context.strokeStyle = "rgb(255, 255, 255)";
      context.lineWidth = Const.LINE_WIDTH;
      context.moveTo(Board.divide, 0);
      context.lineTo(Board.divide, Board.canvas.height);
      context.moveTo(Board.divide * 2, 0);
      context.lineTo(Board.divide * 2, Board.canvas.height);
      context.moveTo(0, Board.divide);
      context.lineTo(Board.canvas.width, Board.divide);
      context.moveTo(0, Board.divide * 2);
      context.lineTo(Board.canvas.width, Board.divide * 2);
      context.stroke();
      results = [];
      for (i = j = 0, ref = board.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        x = Board.divide * (i % 3);
        y = Board.divide * Math.floor(i / 3);
        context.beginPath();
        if (difficulty) {
          context.strokeStyle = "rgba(255, 255, 255, 1)";
        } else {
          context.strokeStyle = Board.clr(board, i);
        }
        if (board[i] === Const.NOUGHT) {
          context.moveTo(x + Board.divide, y + Board.radius);
          context.arc(x + Board.radius + 2, y + Board.radius, Board.radius - 5, 0, Math.PI * 2, false);
        } else if (board[i] === Const.CROSS) {
          context.moveTo(x + 10, y + 10);
          context.lineTo(x + Board.divide - 10, y + Board.divide - 10);
          context.moveTo(x + Board.divide - 10, y + 10);
          context.lineTo(x + 10, y + Board.divide - 10);
        }
        results.push(context.stroke());
      }
      return results;
    };

    Board.clr = function(board, idx) {
      var cnt, j, ref, ret, val;
      ret = "rgba(255, 255, 255, 1)";
      cnt = 0;
      ref = board._q;
      for (j = ref.length - 1; j >= 0; j += -1) {
        val = ref[j];
        if (!(val[1] === board[idx])) {
          continue;
        }
        if (val[0] === idx) {
          ret = (function() {
            switch (cnt) {
              case 0:
                return "rgba(255, 255, 255, 1)";
              case 1:
                return "rgba(255, 255, 255, 0.8)";
              case 2:
                return "rgba(255, 255, 255, 0.3)";
            }
          })();
          break;
        }
        cnt += 1;
      }
      return ret;
    };

    Board.init = function(board) {
      var i, j, ref;
      Board.lineno = null;
      Board.divide = Board.canvas.width / 3;
      Board.radius = Board.divide / 2;
      board.teban = null;
      for (i = j = 0, ref = board.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        board[i] = null;
      }
      board._q = [];
      return board._i = 0;
    };

    function Board(args, teban, move, _q, _i) {
      var i, j, ref;
      if (args == null) {
        args = [null, null, null, null, null, null, null, null, null];
      }
      if (teban == null) {
        teban = null;
      }
      if (move == null) {
        move = null;
      }
      if (_q == null) {
        _q = [];
      }
      if (_i == null) {
        _i = 0;
      }
      this.clone = bind(this.clone, this);
      for (i = j = 0, ref = args.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.push(args[i]);
      }
      this.teban = teban;
      this.move = move;
      this._q = [].concat(_q);
      this._i = _i;
      Board.canvas = document.getElementById("canvasMain");
      Board.statusarea = document.getElementById("spanStatus");
    }

    Board.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this, this.teban, this.move);
      temp._q = [].concat(this._q);
      temp._i = this._i;
      return temp;
    };

    Board.prototype.wonorlost = function() {
      var i, j, len, line, piece, ref;
      ref = Board.lines;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        line = ref[i];
        piece = this[line[0]];
        if (piece && piece === this[line[1]] && piece === this[line[2]]) {
          Board.lineno = i;
          return piece;
        }
      }
      if (indexOf.call(this, null) >= 0) {
        return null;
      }
      return 0;
    };

    Board.prototype.set = function(i, v) {
      if (this[i] || (i > 8) || (i < 0)) {
        console.log("=== Error Board.set =========");
      } else {
        this[i] = v;
      }
      this._q.push([i, v]);
      this._i += 1;
      if (this._i > Const.GAUGE) {
        return this[this._q[this._i - Const.GAUGE - 1][0]] = null;
      }
    };

    Board.prototype.unset = function() {
      var temp;
      temp = this._q.pop();
      if (temp) {
        this._i -= 1;
        if (this._i >= Const.GAUGE) {
          this[this._q[this._i - Const.GAUGE][0]] = this._q[this._i - Const.GAUGE][1];
        }
        return this[temp[0]] = null;
      }
    };

    return Board;

  })(Array);

  Player = (function() {
    function Player(sengo) {
      this.sengo = sengo != null ? sengo : Const.CROSS;
      this.trees = null;
      this.p_status = null;
      this.statusarea = document.getElementById("spanStatus");
      this.startbtn = document.getElementById("btnStart");
      this.labelprogress = document.getElementById("trees");
    }

    Player.prototype.learning = function(result, history) {
      var limit;
      limit = history.length;
      this.learning_chunk(0, limit, result, history, 0);
    };

    Player.prototype.learning_chunk = function(counter, limit, result, history, pre_index) {
      var aryValue, board, buf, compressed, dose, e, inc, positive, storageSize, turn;
      if (counter === 0) {
        board = history.pop();
        this.learning_chunk(counter + 1, limit, result, history, board.move);
        return;
      }
      if (counter < limit) {
        dose = history.length / (limit - 1);
        switch (result) {
          case Const.CROSS:
            inc = this.sengo === Const.CROSS ? 3.0 * dose : -1.0 * dose;
            break;
          case Const.DRAW:
            inc = 1.0;
            break;
          case Const.NOUGHT:
            inc = this.sengo === Const.NOUGHT ? 3.0 * dose : -1.0 * dose;
            break;
          default:
            console.log("Error in Player.learning");
        }
        board = history.pop();
        buf = this.trees.search(board);
        if (buf != null) {
          aryValue = Tree.toAry(buf.value);
          turn = (board._q.length % 2) === 0 ? Const.CROSS : Const.NOUGHT;
          if (this.sengo === turn) {
            buf.score[pre_index] += inc;
          }
          if (buf.score[pre_index] <= 0.1) {
            positive = Math.min.apply(this, buf.score);
            positive = positive != null ? Math.abs(positive) + Const.PEBBLES : Const.PEBBLES;
            buf.score = buf.score.map(function(i) {
              if (i !== null) {
                return i + positive;
              } else {
                return null;
              }
            });
          }
          setTimeout(((function(_this) {
            return function() {
              return _this.learning_chunk(counter + 1, limit, result, history, board.move);
            };
          })(this)), 300);
        } else {
          if (buf === null && history.length !== 0) {
            this.statusarea.innerHTML = Const.DATA_NO_NODE;
          }
        }
      } else {
        try {
          compressed = LZString.compressToUTF16(JSON.stringify(this.trees));
          localStorage.setItem("SerializedVanData", compressed);
        } catch (error) {
          e = error;
          storageSize = Math.round(JSON.stringify(localStorage).length / 1024);
          console.log("Limit Reached: " + storageSize + "K");
          console.log(e);
          this.statusarea.innerHTML = Const.DATA_LEARN_WRITE_ERROR;
          return false;
        }
        $.mobile.loading('hide');
        this.p_status = null;
      }
    };

    Player.prototype.prepare = function() {
      var buf, compressed, e, elem;
      elem = document.getElementById("initialdata");
      buf = JSON.parse(elem.textContent);
      compressed = LZString.compressToUTF16(JSON.stringify(buf));
      try {
        localStorage.setItem('SerializedVanData', compressed);
      } catch (error) {
        e = error;
        console.log('Storage failed: ' + e);
      }
      this.statusarea.innerHTML = Const.RESTART_MSG;
      localStorage.setItem("InitializedVan", true);
      $.mobile.loading('hide');
      console.log('complete!');
    };

    Player.prototype.check = function(board) {
      var j, l, len, piece, ref;
      if (!(indexOf.call(board, null) >= 0)) {
        return true;
      }
      ref = Board.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        piece = board[l[0]];
        if ((piece != null) && piece === board[l[1]] && piece === board[l[2]]) {
          return true;
        }
      }
      return false;
    };

    return Player;

  })();

  Game = (function() {
    function Game() {
      var special_event;
      this.board = new Board([null, null, null, null, null, null, null, null, null]);
      this.man_player = new Player(Const.CROSS);
      this.cpu_player = new Player(Const.NOUGHT);
      this.difficulty = document.getElementsByName("radio-difficulty");
      this.spec_learn = document.getElementById("flipSwitch");
      this.startbtn = document.getElementById("btnStart");
      this.statusarea = document.getElementById("spanStatus");
      this.win_easy_count = document.getElementById("spanEasyWin");
      this.lose_easy_count = document.getElementById("spanEasyLose");
      this.win_normal_count = document.getElementById("spanNormalWin");
      this.lose_normal_count = document.getElementById("spanNormalLose");
      special_event = typeof cordova === "undefined" ? "DOMContentLoaded" : "deviceready";
      this.setEventListener(special_event);
      this.status = null;
      this.history = [];
      this.init();
    }

    Game.prototype.encrypt = function(src, key) {
      var enc, encrypted, i, j, ref;
      encrypted = [];
      for (i = j = 0, ref = src.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        enc = src.charCodeAt(i) ^ key.charCodeAt(i);
        encrypted.push(enc);
      }
      return encrypted;
    };

    Game.prototype.init = function() {
      var data, decompressed, e, err, idx, initialFlg, src;
      initialFlg = localStorage.getItem("InitializedVan");
      if (initialFlg != null) {
        data = localStorage.getItem("SerializedVanData");
        if (data != null) {
          try {
            decompressed = LZString.decompressFromUTF16(data);
            src = JSON.parse(decompressed || null);
            this.cpu_player.trees = Tree.deserialize(src);
          } catch (error) {
            e = error;
            this.statusarea.innerHTML = Const.DATA_READ_ERROR;
            console.log(e);
          }
        } else {
          this.statusarea.innerHTML = Const.DATA_READ_ERROR;
        }
      }
      try {
        idx = parseInt(localStorage.getItem("difficulty"), 10);
        if (isNaN(idx)) {
          this.difficulty[1].checked = true;
        } else {
          this.difficulty[idx].checked = true;
        }
        this.spec_learn.selectedIndex = parseInt(localStorage.getItem("spec_learn"), 10);
        this.win_easy_count.innerHTML = localStorage.getItem("win_easy_count");
        this.lose_easy_count.innerHTML = localStorage.getItem("lose_easy_count");
        this.win_normal_count.innerHTML = localStorage.getItem("win_normal_count");
        return this.lose_normal_count.innerHTML = localStorage.getItem("lose_normal_count");
      } catch (error) {
        err = error;
        console.log("=== Error ===");
        console.log(err);
        this.spec_learn.selectedIndex = 0;
        this.win_easy_count.innerHTML = "0";
        this.lose_easy_count.innerHTML = "0";
        this.win_normal_count.innerHTML = "0";
        return this.lose_normal_count.innerHTML = "0";
      }
    };

    Game.prototype.btnstart = function(target) {
      var idx, initialFlg, locate;
      if (Board.request != null) {
        cancelRequestAnimFrame(Board.request);
      }
      this.history = [];
      Board.init(this.board);
      this.board.move = null;
      this.history.push(this.board.clone());
      initialFlg = localStorage.getItem("InitializedVan");
      if (initialFlg == null) {
        $.mobile.loading('show', {
          text: Const.INITIALIZING_MSG,
          textVisible: true,
          textonly: false
        });
        setTimeout(((function(_this) {
          return function() {
            return _this.cpu_player.prepare();
          };
        })(this)), 500);
        Board.display(this.board, 0, this.difficulty[Const.NORMAL].checked);
        return;
      }
      this.init();
      idx = Math.floor(Math.random() * 2);
      if (idx === 0) {
        this.man_player.sengo = Const.NOUGHT;
        this.cpu_player.sengo = Const.CROSS;
      } else {
        this.man_player.sengo = Const.CROSS;
        this.cpu_player.sengo = Const.NOUGHT;
      }
      if (this.cpu_player.sengo === Const.CROSS) {
        locate = this.cpu_player.trees.apply(this.board);
        this.board.set(locate, Const.CROSS);
        this.board.teban = Const.NOUGHT;
        this.board.move = locate;
        this.history.push(this.board.clone());
      } else {
        this.board.teban = Const.CROSS;
      }
      this.prepared();
      return Board.display(this.board, 0, this.difficulty[Const.NORMAL].checked);
    };

    Game.prototype.touch = function(clientX, clientY) {
      var clickX, clickY, judge, locate;
      if (this.status == null) {
        console.log("cancel");
        return;
      }
      clickX = Math.floor(clientX / Board.divide);
      clickY = Math.floor(clientY / Board.divide);
      locate = clickX + clickY * 3;
      if (this.board[locate] !== null) {
        console.log("not null");
        return;
      }
      this.board.set(locate, this.man_player.sengo);
      this.board.teban = this.cpu_player.sengo;
      this.board.move = locate;
      this.history.push(this.board.clone());
      judge = this.board.wonorlost();
      Board.display(this.board, judge, this.difficulty[Const.NORMAL].checked);
      if (judge != null) {
        this.gameover(judge);
        if (this.spec_learn.selectedIndex === Const.ON) {
          $.mobile.loading('show', {
            text: Const.SAVING_MESSAGE,
            textVisible: true,
            textonly: false
          });
          setTimeout(((function(_this) {
            return function() {
              var event;
              event = new $.Event('ending', {
                judge: judge,
                history: _this.history
              });
              return $(window).trigger(event);
            };
          })(this)), 0);
        }
      } else {
        setTimeout(((function(_this) {
          return function() {
            var event;
            event = new $.Event('cputhinking');
            return $(window).trigger(event);
          };
        })(this)), 0);
      }
    };

    Game.prototype.setCanvasSize = function(w, h) {
      if (w <= h) {
        Board.canvas.width = w * 0.85;
        Board.canvas.height = w * 0.85;
      } else {
        Board.canvas.width = h * 0.85;
        Board.canvas.height = h * 0.85;
      }
    };

    Game.prototype.setEventListener = function(special) {
      $(window).on('cputhinking', (function(_this) {
        return function(e) {
          var judge, locate;
          locate = _this.cpu_player.trees.apply(_this.board);
          if (locate == null) {
            _this.statusarea.innerHTML = Const.DATA_ERROR;
          }
          _this.board.set(locate, _this.cpu_player.sengo);
          _this.board.teban = _this.man_player.sengo;
          _this.board.move = locate;
          _this.history.push(_this.board.clone());
          judge = _this.board.wonorlost();
          Board.display(_this.board, judge, _this.difficulty[Const.NORMAL].checked);
          if (judge != null) {
            _this.gameover(judge);
            if (_this.spec_learn.selectedIndex === Const.ON) {
              $.mobile.loading('show', {
                text: Const.SAVING_MESSAGE,
                textVisible: true,
                textonly: false
              });
              setTimeout((function() {
                var event;
                event = new $.Event('ending', {
                  judge: judge,
                  history: _this.history
                });
                return $(window).trigger(event);
              }), 0);
            }
          }
        };
      })(this));
      $(window).on('ending', (function(_this) {
        return function(e) {
          return _this.cpu_player.learning(e.judge, e.history);
        };
      })(this));
      $('input[name="radio-difficulty"]').on('change', (function(_this) {
        return function(e) {
          var err, target;
          target = $(e.currentTarget);
          try {
            if (_this.difficulty[Const.EASY].checked) {
              return localStorage.setItem("difficulty", Const.EASY);
            } else {
              return localStorage.setItem("difficulty", Const.NORMAL);
            }
          } catch (error) {
            err = error;
            return console.log(err);
          }
        };
      })(this));
      $('#flipSwitch').on('change', (function(_this) {
        return function(e) {
          var err, target;
          target = $(e.currentTarget);
          try {
            return localStorage.setItem("spec_learn", target.context.selectedIndex);
          } catch (error) {
            err = error;
            return console.log(err);
          }
        };
      })(this));
      $('#canvasMain').on('click', (function(_this) {
        return function(e) {
          var rect;
          rect = e.target.getBoundingClientRect();
          return _this.touch(e.clientX - rect.left, e.clientY - rect.top);
        };
      })(this));
      $('#btnStart').on('click', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          return _this.btnstart(target);
        };
      })(this));
      $(window).on('load', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          _this.setCanvasSize(target.width(), target.height());
          Board.divide = Board.canvas.width / 3;
          Board.radius = Board.divide / 2;
          Board.display(_this.board, 0, _this.difficulty[Const.NORMAL].checked);
          return $('body').pointer({
            'divide': Board.divide
          });
        };
      })(this));
      return $(window).on(special, (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
        };
      })(this));
    };

    Game.prototype.outputRecord = function(winner, difficulty) {
      var err, lose_easy_count, lose_normal_count, win_easy_count, win_normal_count;
      try {
        win_easy_count = parseInt(localStorage.getItem("win_easy_count"), 10);
        lose_easy_count = parseInt(localStorage.getItem("lose_easy_count"), 10);
        win_normal_count = parseInt(localStorage.getItem("win_normal_count"), 10);
        lose_normal_count = parseInt(localStorage.getItem("lose_normal_count"), 10);
        if (!win_easy_count) {
          win_easy_count = 0;
        }
        if (!lose_easy_count) {
          lose_easy_count = 0;
        }
        if (!win_normal_count) {
          win_normal_count = 0;
        }
        if (!lose_normal_count) {
          lose_normal_count = 0;
        }
        if (difficulty[Const.EASY].checked) {
          if (this.man_player.sengo === winner) {
            win_easy_count += 1;
            return localStorage.setItem("win_easy_count", win_easy_count);
          } else {
            if (this.cpu_player.sengo === winner) {
              lose_easy_count += 1;
              return localStorage.setItem("lose_easy_count", lose_easy_count);
            }
          }
        } else {
          if (this.man_player.sengo === winner) {
            win_normal_count += 1;
            return localStorage.setItem("win_normal_count", win_normal_count);
          } else {
            if (this.cpu_player.sengo === winner) {
              lose_normal_count += 1;
              return localStorage.setItem("lose_normal_count", lose_normal_count);
            }
          }
        }
      } catch (error) {
        err = error;
        console.log(err);
        win_easy_count = 0;
        lose_easy_count = 0;
        win_normal_count = 0;
        return lose_normal_count = 0;
      } finally {
        this.win_easy_count.innerHTML = win_easy_count;
        this.lose_easy_count.innerHTML = lose_easy_count;
        this.win_normal_count.innerHTML = win_normal_count;
        this.lose_normal_count.innerHTML = lose_normal_count;
      }
    };

    Game.prototype.gameover = function(winner) {
      var j, len, msg, ref, v;
      this.startbtn.disabled = false;
      ref = this.difficulty;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        v.disabled = false;
      }
      msg = (function() {
        switch (winner) {
          case Const.CROSS:
            return "×の勝ち";
          case Const.NOUGHT:
            return "◯の勝ち";
          case Const.DRAW:
            return "引き分け";
          default:
            return "";
        }
      })();
      this.statusarea.innerHTML = msg;
      this.outputRecord(winner, this.difficulty);
      this.cpu_player.p_status = true;
      return this.status = null;
    };

    Game.prototype.prepared = function() {
      var j, len, ref, results, v;
      this.statusarea.innerHTML = "";
      this.status = true;
      this.startbtn.disabled = true;
      ref = this.difficulty;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        results.push(v.disabled = true);
      }
      return results;
    };

    return Game;

  })();

  window.Game = window.Game || Game;

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 0);
    };
  })();

  window.cancelRequestAnimFrame = (function() {
    return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
  })();

}).call(this);

//# sourceMappingURL=tictactoe.js.map
